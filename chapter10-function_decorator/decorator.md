chapter10-function_decorator\decorator_prerequisite.md을 통해 

장식자를 만드는데 필요한 모든 Python 기법들을 살펴봤다. 

장식자를 만들 때 특정 규칙의 집합 또는 비법을 따라야 한다. 장식자를 이용하면 기존 함수의 코드를 바꾸지 않고 기존 함수에 코드를 추가할 수 있다. 

## 함수 장식자를 만들기 위해서 알아야 하는 4가지 내용 

1. 함수 장식자는 함수다. 
    - 인터프리터 입장에서 함수 장식자는 기존 함수를 이용한 또 다른 함수일 뿐
    - 여기서의 기존 함수를 장식된 함수라고 하겠다. 

2. 장식자는 장식된 함수를 인자로 받는다.
    - 즉, `장식된 함수`를 `함수 객체`로 장식자에 전달한다. 
    - 괄호를 사용하지 않고 함수이름을 이용해서 함수 객체에 접근할 수 있다는 걸 배웠다. 

3. 장식자는 새로운 함수를 반환한다. 
    - 함수를 return할 뿐만 아니라 그 함수를 호출해야 한다. 
    - 어렵지 않다. prerequisite에서 다룬 내용이다. 

4. 장식자는 장식된 함수의 signature를 유지한다. 
    - 장식자는 `장식된 함수와 동일한 개수의 인자와 유형을 갖는 함수`를 반환해야 한다. 
    - def 행으로 정의하는 함수의 인자 개수와 유형 정보를 signature라고 한다. 

이제 장식자를 만들어보자. 

이 일을 하는 이유 - 로그인 상태 확인 코드를 복사/붙여넣기 하지 않는 더 좋은 방법으로 추가하기 위함 

## 함수 장식자 만들기 

- 최종적으로 만들어진 장식자 코드 
```
from flask import session

from functools import wraps

def check_logged_in(func) : 
    @wraps(func) 
    def wrapper(*args, **kwargs): 
        if 'logged_in' in session :
            return func(*args, **kwargs)
        
        return 'You are NOT logged in'

    return wrapper
```

- 장식자를 적용한 부분 
```
@app.route('/page2')
@check_logged_in
def page2():
    return 'This is page 2.'
```

page2 함수에 장식자 하나만 추가함으로써 원하는 기능을 추가할 수 있게 되었다. 만약 해당 페이지에 로그인 확인 기능을 빼고 싶다면 장식자만 삭제하면 된다. 

### 장식자의 장점
1. 로직 추상화 
2. 기존 함수의 코드를 바꾸지 않고도 기존 함수의 동작을 변경 가능


### 코드에 새로운 기능을 추가한다는 점에서 컨텍스트 관리자와 장식자 기능은 같지 않은가? 

같은 점도 있고 다른 점도 있다. 

- 공통점 : 둘 다 기존 코드에 로직을 추가로 제공한다는 점 

- 차이점
    - 장식자 
        1. 기존 함수에 새로운 기능을 추가하는데 최적화
        2. 장식된 함수를 호출한 다음 어떤 작업을 하도록 정의하는 규칙이 없다. 
    - 컨텍스트 관리자 : 특정 컨텍스트 안에서 코드를 실행하면서 with문 이전 그리고 with문이 끝난 다음에 적절하게 코드가 실행되도록 관리하는 것이 주된 목적 