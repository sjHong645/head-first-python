# 순서가 있는 데이터로 작업하기

### 객체

파이썬에서는 모든 것이 `객체`이다. 
즉, 숫자, 문자열, 함수, 모듈 등도 객체로 취급한다는 뜻이다. 

결과적으로 모든 객체를 변수에 할당할 수 있다.

## 파이썬에서는 모든 것이 객체이다. 

`"이것저것"`이라는 문자열 객체도 있고 `43`이라는 숫자 객체도 있다. 

파이썬의 각각의 객체는 
- 다른 언어와 마찬가지로 속성이나 값을 나타내는 상태(state)
- 메서드에 해당하는 행동(behavior)

을 가질 수 있다. 

### 그러면, 파이썬은 객체 지향인가? 

그렇다. 

클래스, 객체, 인스턴스 등을 이용해 파이썬을 객체 지향 방식으로 프로그래밍할 수 있다. 하지만, 꼭 그래야 하는 건 아니다. 

클래스가 없어도 코드만 있으면 잘 동작한다. 자바와 달리 파이썬은 클래스를 만들 필요없이 필요한 코드만 구현하면 된다. 

파이썬의 모든 것은 클래스로부터 상속받은 객체처럼 동작하기 때문에
객체 지향이라기 보다는 `객체 기반(object-based)`이라고 표현하는 것이 더 적절하다. 

즉, 파이썬에서의 객체 지향은 단지 `선택사항`일 뿐이다. 

### 그래서 뭐 어쩌라고? 

파이썬에서는 모든 것이 객체이기 때문에 어떤 것(숫자, 문자열, 함수, 위젯 등)도 변수에 할당할 수 있다. 더 자세한 내용은 차차 다룬다. 

## 리스트 : 순서가 있으며 변경할 수 있는 객체 컬렉션

- `배열`과 비슷하다. 
    - 그래서 데이터가 순서가 정해지면서 저장된다. 
    - 다른 프로그래밍 언어와의 차이점은 리스트 자체의 크기가 동적으로 달라진다는 점이다.
    - 그래서 크기가 늘어나거나 줄어들기도 한다. 

- 변경할 수 있다(mutable)
    - 리스트에 객체를 추가, 삭제, 변경할 수 있다.

## 튜플 : 순서가 있으며 변경할 수 없는 객체 컬렉션

- 변경할 수 없다(immutable)
    - 때문에 어떤 객체가 변경되지 않아야 되는 상황에서 사용된다. 
    - 자세한 내용은 3장에서 

## 딕셔너리 : 순서가 없는 key-value 쌍의 집합 

- 다른 프로그래밍 언어에서의 Hash, Map 이라는 개념과 유사함 
- 고유한 key값과 그와 매핑된 value로 이뤄진 하나의 쌍을 여러 개 저장한 컬렉션 

- 순서가 없음
    - 필요하다면 dictionary의 데이터를 특정 순서로 출력할 수 있음 

## 집합 : 순서가 없는 고유 객체의 모임 

- 중복된 자료를 빠르게 제거할 때 유용하게 사용

이제 리스트에 대해서 좀 더 자세하게 살펴보자. 

# 리스트 

## 파이선에서 제공하는 list 관련 리스트 

ex. nums = [1, 2, 3, 4, 5]

- remove : `값을 인자`로 받고 그 값을 리스트에서 제거하는 메서드 
    - nums.remove(3) : 3이라는 값을 리스트에서 제거

- pop : `인덱스를 인자`로 받고 해당 인덱스의 값을 리스트에서 출력 및 제거하는 메서드
    - nums.pop() : 전달한 인자가 없으면 마지막에 있는 데이터를 출력하면서 제거 
    - nums.pop(1) : 1번째 데이터를 출력하면서 제거 

- extend : `리스트를 인자`로 받고 그 리스트를 기존 리스트에 추가
    - nums.extend([44, 55])
        - 결과 : [1, 2, 3, 4, 5, 44, 55]

    - nums.append([44, 55])
        - 결과 : [[1, 2, 3, 4, 5], [44, 55]]

    - 결과는 오른쪽 끝에 추가함 

- insert : `인덱스의 값과 객체를 인자`로 받음 
    - nums.insert(0, 22)
        - 기존 리스트의 0번째 값 앞에 22라는 객체를 추가함
        - 결과 : [22, 1, 2, 3, 4, 5]

    - nums.insert(2, "two-three")
        - 기존 리스트의 2번째 값 앞에 "two-three"라는 객체를 추가함
        - 결과 : [1, 2, 'two-three', 3, 4, 5]


## 얕은복사 vs 깊은복사 

- 얕은복사 
ex. first = [1, 2, 3, 4, 5]
    second = first 

위와 같이 설정하면 first와 second는 같은 리스트를 가리키기 때문에 second에서 리스트를 조작하면 first 역시 조작된 리스트에 접근한다. 

- 깊은복사 
ex. first = [1, 2, 3, 4, 5]
    second = first.copy()

내용은 똑같지만 엄연히 서로 다른 리스트를 가리키게 된다. 

## 리스트 인덱스 표기 

ex. letters = ['D', 'o', 'n', "'", 't', ' ', 'p', 'a', 'n', 'i', 'c', '!']

cf. list를 하나의 문자열로 반환
- ''.join(letters) => letters에 있는 각각의 값을 빈칸없이 결합 

- '  '.join(letters) => letters에 있는 각각의 값을 두 칸 띄고 결합 

letters[3] => "'" 출력 
    - `양수 인덱싱`을 할 때는
    - 첫 번째 인덱스값을 0으로 설정한다. 

letters[-3] => 'i' 출력 (마지막에서 3번째)
    - `음수 인덱싱`을 할 때는
    - 마지막의 첫 번째 인덱스 값을 1로 설정한다.

### 슬라이스 

letters[시작:중지:스텝]
- 시작의 기본값 = 0 / 중지의 기본값 = 리스트의 가장 마지막 인덱스 값 / 스텝의 기본값 = 1

- letters[1:9:3] : 1번째 값부터 9번째 값을 3칸 간격으로 출력 => ['o', 't', 'a'] = [1번째 값, 4번째 값, 7번째 값]

- letters[3:] : 3번째 값 이후부터의 값을 반환

- letters[-6:] : -6번째 값(=마지막에서 6번째 값) 이후부터의 값을 반환

- letters[:7] : (7-1)번째 까지의 값을 반환 

- letters[:-6] : (-6-1)번째 값(=마지막에서 7번째 값)까지의 값을 반환

- letters[::2] : 모든 값을 2칸 간격으로 반환
=> ['D', 'n', 't', 'p', 'n', 'c']

- letters[::-2] : 모든 값을 마지막에서부터 2칸 간격으로 반환
=> ['!', 'i', 'a', ' ', "'", 'o']
