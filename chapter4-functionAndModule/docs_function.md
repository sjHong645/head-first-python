# 코드 재사용

## 함수, 모듈, 라이브러리의 관계 
여러 줄의 코드를 모아놓은 걸 `함수(function)`라 한다.

`함수`를 여러 개 묶어 놓은 파일을 `모듈(module)`이라 한다. 

`모듈`을 여러 개 묶어서 `라이브러리`를 만들 수 있다.

## 파이썬은 매개변수와 함수의 반환 타입 지정을 강제하지 않는다. 

`어노테이션`을 이용해서 어떤 자료형을 사용할 지 권고할 수는 있다. 물론 강제할 수는 없다. 

인터프리터는 매개변수와 함수의 유형에 아무 관심이 없기 때문이다. 

### PEP(Python Enhancement Proposals) 8은 꼭 읽어보자

- 링크 : https://peps.python.org/pep-0008/

- `문자열`은 가능하면 `작은따옴표`를 사용할 것
    - docstring은 큰따옴표를 사용할 것

- pytest-pep8 : PEP 8 규정을 준수하도록 도움을 주는 도구 

1. 설치 방법
```
pip install pytest
pip install pytest-pep8
```

2. 사용방법
```
py-test --pep8 확인하고자하는 파일

ex) py-test --pep8 vsearch.py
```

오류 메시지를 확인하면서 PEP 8을 준수하도록 하자!


### 결과값을 반환할 때

- 결과값이 empty인지 쉽게 확인할 수 있는 메서드 - `bool`
    - bool 메소드의 인자에 뭐라도 있으면 true / 아니면 false를 반환하기 때문
    - bool([]), bool(''), bool({}) => false
    - bool(42), bool('apple'), bool([23, 33]) => true 


## 파이썬에서는 매개변수를 전달할 때 값을 전달할까? 레퍼런스를 전달할까? 

- call by value(값에 의한 호출방식) : 함수 인자의 변수에 `값이 사용`되는 기법 

함수의 suite에서 값이 변경되더라도 함수가 호출한 코드의 변수값은 바뀌지 않는다. 
즉, 원래 변수값을 복사해서 인자로 전달한다고 생각할 수 있다.

만약에 함수 suite에서 변경된 값을 전달받고 싶다면
해당 함수의 return을 통해서 전달받아야 한다. 

- call by reference(레퍼런스에 의한 호출방식) : 함수를 호출한 코드의 변수에 링크를 유지한다. 

함수 suite에서 변수값이 변경된다면 함수를 호출한 코드의 변수값도 바뀐다. 

원래 변수에 이름만 다르게 붙여 인자로 전달한다고 생각할 수 있다. 

그렇기 때문에 굳이 함수 suite에서 변경된 값을 받기 위해 return을 이용할 필요가 없다. 

- 예시 메소드 
```
def double(arg) : 
    print('Before: ', arg)
    arg = arg * 2
    print('After: ', arg)

def change(arg) : 
    print('Before: ', arg)
    arg.append('More data')
    print('After: ', arg)
```

- 상황 1
```
nums = 10
double(num)을 한 이후에 
nums는 여전히 10 
```

- 상황 2 
```
numbers = [42, 256, 16]
change(numbers)을 한 이후에
numbers = [42, 256, 16, 'More data']로 변경됨 
```

그렇다. 파이썬 함수 인자는 call by value, call by reference 모두 지원한다. 

### 상기해야 할 내용 : Python에서의 변수는 객체 레퍼런스이다. 

`변수에 저장된 값`은 사실 `값이 저장된 메모리의 주소`라고 생각하면 편하다. 
즉, 함수를 호출할 때 값이 전달되는 게 아니라 `메모리 주소`가 전달된다. 
엄밀히 말하면 Python 함수는 객체 레퍼런스 전달 기법을 지원한다. 

### 객체 레퍼런스의 유형에 따라 실제 적용되는 기법이 달라진다. 

앞서 call by value, call by reference 모두 적용된 것 처럼 보였다. 
겉으로는 그렇게 보일 뿐 실제 동작은 런타임에 정해진다. 

1. 인터프리터는 객체 레퍼런스(메모리 주소)가 참조하는 값의 유형을 확인

1-1. 변수가 `변할 수 있는 값`을 참조하면 `call by reference 기법` 적용
    - 리스트, 딕셔너리, 집합이 함수의 인자로 전달되면
    - call by reference를 적용한다. 

1-2. 변수가 `변할 수 없는 값`을 참조하면 `call by value 기법` 적용
    - 문자열, 정수, 튜플이 함수의 인자로 전달되면
    - call by value를 적용한다. 

### 앞선 예시로 다시보기 

- 상황 1
```
nums = 10
double(num)을 한 이후에 (내부에서는 20으로 변경됨)
nums는 여전히 10 

=> 바꿀 수 없는 정수값을 전달했으니까 call by value 적용. 
=> 내부에서만 변경되고 원래 변수값은 바뀌지 않음
```

- 상황 2 
```
numbers = [42, 256, 16]
change(numbers)을 한 이후에
numbers = [42, 256, 16, 'More data']로 변경됨 

=> 바꿀 수 있는 리스트를 전달했으니까 call by reference 적용. 
=> 내부에서만 변경되면서 원래 변수값도 변경됨
```

### 또 하나의 의문 

그런데... `double 메소드`에 `numbers = [42, 256, 16]`을 인자로 준다면 앞서 얘기한 것 처럼 `바꿀 수 있는 리스트`를 전달했으니까 

내부에서 변경되면서 원래 변수값도 변경되야 한다. 

```
>>> numbers = [42, 256, 16]
>>> double(numbers)
Before:  [42, 256, 16]
After:  [42, 256, 16, 42, 256, 16]
>>> numbers
[42, 256, 16]
```

하지만, 실행해보면 알겠지만 변경되지 않는다. 왜 그럴까? 

#### double 메소드 
여기서는 코드 `arg = arg * 2`가 `할당문`이라는 사실에 주목해야 한다. 

`할당문`에서는 
- `= 기호의 오른쪽에 있는 연산`이 `먼저 실행`되어 결과값이 객체로 만들어지면 
- 해당 객체의 레퍼런스가 `= 기호의 왼쪽 변수`에 `할당`된다. 

이를 통해 해당 코드를 다시보면 
- `arg * 2`를 실행하면 새로운 값, 즉 새로운 객체 레퍼런스가 만들어진다. 
- 새롭게 만들어진 객체 레퍼런스는 `arg 변수`에 할당된다. 
- `arg 변수`에 할당되면서 원래 함수 suite의 arg에 저장되어 있던 레퍼런스는 겹쳐 써진다. (겹쳐쓴다 : 동일한 이름의 변수를 서로 다른 범위에서 정의하는 것)
    - 결국, 호출 코드에서 사용한 arg 변수는 그대로 남아있고
    - 함수 내부의 지역변수 arg의 값은 전달받은 arg값을 이용해 새롭게 할당된 채 저장된 상황
    - 함수가 종료되고 나면 새롭게 할당했던 지역변수 arg는 사라지고 이전의 arg 값만 남게된다. 

#### change 메소드 
기존 리스트에 `append 메소드`를 실행했다. 

할당문이 없으므로 기존 객체 레퍼런스를 겹쳐쓰지 않는다. 

따라서, change에서는 함수 suite의 reference와 호출 코드의 reference가 동일한 객체 레퍼런스를 가리키므로 변경 내용이 함수 호출 이후에도 적용된 걸 확인할 수 있다. 
