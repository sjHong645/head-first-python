## Context Manager protocol(컨텍스트 관리 프로토콜)

`before_context_applied.py`를 with 문과 연결할 수 있도록 고치는 작업을 이번 장에서 할 것이다. 

`프로토콜`이란 반드시 지켜야 하는 합의된 절차 또는 규칙 집합을 말한다. 

그 전에 `컨텍스트 관리 프로토콜`을 준수하는 방법을 확인하자. 

1. 표준 라이브러리의 contextlib 모듈을 활용해서 간단하게 컨텍스트 관리 프로토콜을 만드는 방법
2. DB 연결 등 with로 외부 객체를 제어해야 하는 상황에서 프로토콜을 준수하는 클래스를 만드는 방법

여기서는 2번이 올바른 방법이다. 그렇다면 `컨텍스트 관리 프로토콜을 준수`한다는 건 뭘 의미하는 걸까? 

### 메서드로 컨텍스트 관리하기 

`컨텍스트 관리 프로토콜`을 준수하는 모든 클래스는 두 가지 요술 메서드를 정의해야 한다.
`__enter__`와 `__exit__` 두 개를 정의해야 한다. 

이 프로토콜을 준수하도록 클래스를 구현하면 with문과 연결할 수 있다. 

#### __enter__는 설정을 담당 

객체에 with문을 사용할 때 인터프리터는 with문의 suite를 시작하기 전에 `객체의 __enter__` 메서드를 호출한다. 
따라서, `__enter__` 내에서 필요한 설정 작업을 수행할 수 있다. 

프로토콜은 `__enter__`가 with문에 반환값을 제공할 수 있음(선택사항)을 명시한다. 

#### __exit__는 마무리를 담당 

with문의 suite가 끝나면 인터프리터는 항상 `객체의 __exit__` 메서드를 호출한다. 
따라서, `__exit__` 메서드에서 필요한 마무리 작업을 수행할 수 있다. 

with문의 suite가 예외 발생 등으로 정상적으로 동작하지 않을 수 있으므로 여러 상황에 대비할 수 있도록 `__exit__` 메서드를 구현해야 한다. 

자, `__enter__`와 `__exit__` 메서드를 클래스에 정의했다면 인터프리터는 자동으로 해당 클래스를 컨텍스트 관리자로 인식하여 with문과 연결할 수 있게 된다. 즉, 컨텍스트 관리 프로토콜을 준수하고 컨텍스트 관리자를 구현하는 클래스를 완성하는 것이다. 

### 이전에 사용했던 코드로 컨텍스트 관리자가 어떻게 동작하는지 살펴보자.

- 아래 코드에서 `__enter__`, `__exit__`, `__init__`이 어디에 호출되었는지 살펴보자.

```
with open('todos.txt') as tasks : 
    for chors in tasks : 
        print(chore, end = '')
```
